// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWStructuredBuffer<float3> _vertices;
RWStructuredBuffer<float3> _normals;
RWStructuredBuffer<float2> _uv;
RWStructuredBuffer<float2> _uv2;
RWStructuredBuffer<int> _triangles;

RWStructuredBuffer<float4> _colors;
RWStructuredBuffer<float> _lllumination;


RWTexture2D<float4> _mainTexture;

int _mainTextureWight;
int _mainTextureHeight;

//Functions
void calcBlock(uint3 id);

void calcTriangles(uint3 id, int index);
void calcNormal(uint3 id, int index);

bool isBlockExist(uint3 id);
float getlllumination(uint3 id);

//Get light for point of side cube
float getLightL_DB(uint3 id);
float getLightL_UB(uint3 id);
float getLightL_UF(uint3 id);
float getLightL_DF(uint3 id);

float getLightD_LB(uint3 id);
float getLightD_LF(uint3 id);
float getLightD_RF(uint3 id);
float getLightD_RB(uint3 id);

float getLightB_LD(uint3 id);
float getLightB_LU(uint3 id);
float getLightB_RU(uint3 id);
float getLightB_RD(uint3 id);


[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	//check all 32 z positions
	for(uint z = 0; z < 32; z++){
		uint3 index = uint3(id.x, id.y, z);
		calcBlock(index);
	}
}

void calcBlock(uint3 id){

	//int indexMax = 32*32*32;

	//get global index
	int index = id.z + id.y * 32 + id.x * 32 * 32;

	int indexB = (id.z - 1) + id.y * 32 + id.x * 32 * 32;
	int indexD = id.z + (id.y - 1) * 32 + id.x * 32 * 32;
	int indexL = id.z + id.y * 32 + (id.x - 1) * 32 * 32;


	float4 color = _colors[index];

	//get color if Neibour exist
	float4 colorL = float4(0.0f, 0.0f, 0.0f, 0.0f);
	if(indexL >= 0){
		colorL = _colors[indexL];
	}
	float4 colorD = float4(0.0f, 0.0f, 0.0f, 0.0f);
	if(indexD >= 0){
		colorD = _colors[indexD];
	}
	float4 colorB = float4(0.0f, 0.0f, 0.0f, 0.0f);
	if(indexB >= 0){
		colorB = _colors[indexB];
	}

	int num = id.x + id.y * 32 + id.z * 32 * 32;
	int numVertStart = num * 4 * 3;
	int numTrianStart = num * 3 * 2 * 3;

	uint2 texturePos = uint2(num % _mainTextureWight, num / _mainTextureWight);
	float uvXsize = 1.0f / _mainTextureWight;
	float uvYsize = 1.0f / _mainTextureHeight;
	float uvXnow =  texturePos.x * uvXsize;
	float uvYnow =  texturePos.y * uvYsize;

	//for(int num = 0; num < 12; num++)
	//	_uv2[numVertStart + num] = float2(0.9f, 0);


	//Left, Down, Back
	if(color.w > 0.9f)
	{
		//Left
		if(indexL >= 0 && colorL.w <= 0.9f || indexL < 0){
			_triangles[numTrianStart + 0] = numVertStart;
			_triangles[numTrianStart + 1] = numVertStart + 3;
			_triangles[numTrianStart + 2] = numVertStart + 2;
			
			_triangles[numTrianStart + 3] = numVertStart + 2;
			_triangles[numTrianStart + 4] = numVertStart + 1;
			_triangles[numTrianStart + 5] = numVertStart;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num] = float3(-1.0f, 0.0f, 0.0f);

			_uv[numVertStart + 0] = float2(uvXnow, uvYnow);
			_uv[numVertStart + 1] = float2(uvXnow, uvYnow + uvYsize);
			_uv[numVertStart + 2] = float2(uvXnow + uvXsize, uvYnow + uvYsize);
			_uv[numVertStart + 3] = float2(uvXnow + uvXsize, uvYnow);

			uint3 posLeft = uint3(id.x-1, id.y, id.z);
			//float light = getlllumination(uint3(id.x - 1, id.y, id.z));
			_uv2[numVertStart + 0] = float2(getLightL_DB(posLeft), 0);
			_uv2[numVertStart + 1] = float2(getLightL_UB(posLeft), 1);
			_uv2[numVertStart + 2] = float2(getLightL_UF(posLeft), 1);
			_uv2[numVertStart + 3] = float2(getLightL_DF(posLeft), 0);
		}
		//Down
		if(indexD >= 0 && colorD.w <= 0.9f || indexD < 0){
			_triangles[numTrianStart + 6 + 0] = numVertStart + 4;
			_triangles[numTrianStart + 6 + 1] = numVertStart + 4 + 3;
			_triangles[numTrianStart + 6 + 2] = numVertStart + 4 + 2;
			
			_triangles[numTrianStart + 6 + 3] = numVertStart + 4 + 2;
			_triangles[numTrianStart + 6 + 4] = numVertStart + 4 + 1;
			_triangles[numTrianStart + 6 + 5] = numVertStart + 4;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num + 4] = float3(0.0f, -1.0f, 0.0f);

			_uv[numVertStart + 0 + 4] = float2(uvXnow, uvYnow);
			_uv[numVertStart + 1 + 4] = float2(uvXnow, uvYnow + uvYsize);
			_uv[numVertStart + 2 + 4] = float2(uvXnow + uvXsize, uvYnow + uvYsize);
			_uv[numVertStart + 3 + 4] = float2(uvXnow + uvXsize, uvYnow);

			uint3 posDown = uint3(id.x, id.y-1, id.z);
			//float light = getlllumination(uint3(id.x, id.y - 1, id.z));
			_uv2[numVertStart + 0 + 4] = float2(getLightD_LB(posDown), 0);
			_uv2[numVertStart + 1 + 4] = float2(getLightD_LF(posDown), 1);
			_uv2[numVertStart + 2 + 4] = float2(getLightD_RF(posDown), 1);
			_uv2[numVertStart + 3 + 4] = float2(getLightD_RB(posDown), 0);
		}
		//Back
		if(indexB >= 0 && colorB.w <= 0.9f || indexB < 0){
			_triangles[numTrianStart + 12 + 0] = numVertStart + 8;
			_triangles[numTrianStart + 12 + 1] = numVertStart + 8 + 3;
			_triangles[numTrianStart + 12 + 2] = numVertStart + 8 + 2;

			_triangles[numTrianStart + 12 + 3] = numVertStart + 8 + 2;
			_triangles[numTrianStart + 12 + 4] = numVertStart + 8 + 1;
			_triangles[numTrianStart + 12 + 5] = numVertStart + 8;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num + 8] = float3(0.0f, 0.0f, -1.0f);

			_uv[numVertStart + 0 + 8] = float2(uvXnow, uvYnow);
			_uv[numVertStart + 1 + 8] = float2(uvXnow, uvYnow + uvYsize);
			_uv[numVertStart + 2 + 8] = float2(uvXnow + uvXsize, uvYnow + uvYsize);
			_uv[numVertStart + 3 + 8] = float2(uvXnow + uvXsize, uvYnow);

			uint3 posDown = uint3(id.x, id.y, id.z-1);
			//float light = getlllumination(uint3(id.x, id.y, id.z - 1));
			_uv2[numVertStart + 0 + 8] = float2(getLightB_RD(posDown), 0);
			_uv2[numVertStart + 1 + 8] = float2(getLightB_RU(posDown), 1);
			_uv2[numVertStart + 2 + 8] = float2(getLightB_LU(posDown), 1);
			_uv2[numVertStart + 3 + 8] = float2(getLightB_LD(posDown), 0);
		}

	}
	//Neibour
	else{
		//Left
		if(id.x > 0 && colorL.w > 0.9f){
			_triangles[numTrianStart + 0] = numVertStart;
			_triangles[numTrianStart + 1] = numVertStart + 1;
			_triangles[numTrianStart + 2] = numVertStart + 2;

			_triangles[numTrianStart + 3] = numVertStart + 2;
			_triangles[numTrianStart + 4] = numVertStart + 3;
			_triangles[numTrianStart + 5] = numVertStart;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num] = float3(1.0f, 0.0f, 0.0f);

			int numL = (id.x-1) + id.y * 32 + id.z * 32 * 32;
			uint2 texturePosL = uint2(numL % _mainTextureWight, numL / _mainTextureWight);
			float uvXL =  texturePosL.x * uvXsize;
			float uvYL =  texturePosL.y * uvYsize;
			_uv[numVertStart + 0] = float2(uvXL, uvYL);
			_uv[numVertStart + 1] = float2(uvXL, uvYL + uvYsize);
			_uv[numVertStart + 2] = float2(uvXL + uvXsize, uvYL + uvYsize);
			_uv[numVertStart + 3] = float2(uvXL + uvXsize, uvYL);

			_uv2[numVertStart + 0] = float2(getLightL_DB(id), 0);
			_uv2[numVertStart + 1] = float2(getLightL_UB(id), 1);
			_uv2[numVertStart + 2] = float2(getLightL_UF(id), 1);
			_uv2[numVertStart + 3] = float2(getLightL_DF(id), 0);
		}
		//Neibour Left chank
		else if(id.x == 0){
		
		}
		else{
			for(int num = 0; num < 6; num++)
				_triangles[numTrianStart + num] = 0;
		}
		//Down
		if(id.y > 0 && colorD.w > 0.9f){
			_triangles[numTrianStart + 6 + 0] = numVertStart + 4;
			_triangles[numTrianStart + 6 + 1] = numVertStart + 4 + 1;
			_triangles[numTrianStart + 6 + 2] = numVertStart + 4 + 2;
			
			_triangles[numTrianStart + 6 + 3] = numVertStart + 4 + 2;
			_triangles[numTrianStart + 6 + 4] = numVertStart + 4 + 3;
			_triangles[numTrianStart + 6 + 5] = numVertStart + 4;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num + 4] = float3(0.0f, 1.0f, 0.0f);

			int numD = id.x + (id.y-1) * 32 + id.z * 32 * 32;
			uint2 texturePosL = uint2(numD % _mainTextureWight, numD / _mainTextureWight);
			float uvXD =  texturePosL.x * uvXsize;
			float uvYD =  texturePosL.y * uvYsize;
			_uv[numVertStart + 0 + 4] = float2(uvXD, uvYD);
			_uv[numVertStart + 1 + 4] = float2(uvXD, uvYD + uvYsize);
			_uv[numVertStart + 2 + 4] = float2(uvXD + uvXsize, uvYD + uvYsize);
			_uv[numVertStart + 3 + 4] = float2(uvXD + uvXsize, uvYD);

			_uv2[numVertStart + 0 + 4] = float2(getLightD_LB(id), 0);
			_uv2[numVertStart + 1 + 4] = float2(getLightD_LF(id), 1);
			_uv2[numVertStart + 2 + 4] = float2(getLightD_RF(id), 1);
			_uv2[numVertStart + 3 + 4] = float2(getLightD_RB(id), 0);
		}
		//Neibour Down chank
		else if(id.y == 0){
		
		}
		else{
			for(int num = 0; num < 6; num++)
				_triangles[numTrianStart + num + 6] = 0;
		}

		//Back
		if(id.z > 0 && colorB.w > 0.9f){
			_triangles[numTrianStart + 12 + 0] = numVertStart + 8;
			_triangles[numTrianStart + 12 + 1] = numVertStart + 8 + 1;
			_triangles[numTrianStart + 12 + 2] = numVertStart + 8 + 2;

			_triangles[numTrianStart + 12 + 3] = numVertStart + 8 + 2;
			_triangles[numTrianStart + 12 + 4] = numVertStart + 8 + 3;
			_triangles[numTrianStart + 12 + 5] = numVertStart + 8;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num + 8] = float3(0.0f, 0.0f, 1.0f);

			int numB = id.x + id.y * 32 + (id.z-1) * 32 * 32;
			uint2 texturePosL = uint2(numB % _mainTextureWight, numB / _mainTextureWight);
			float uvXB =  texturePosL.x * uvXsize;
			float uvYB =  texturePosL.y * uvYsize;
			_uv[numVertStart + 0 + 8] = float2(uvXB, uvYB);
			_uv[numVertStart + 1 + 8] = float2(uvXB, uvYB + uvYsize);
			_uv[numVertStart + 2 + 8] = float2(uvXB + uvXsize, uvYB + uvYsize);
			_uv[numVertStart + 3 + 8] = float2(uvXB + uvXsize, uvYB);

			_uv2[numVertStart + 0 + 8] = float2(getLightB_RD(id), 0);
			_uv2[numVertStart + 1 + 8] = float2(getLightB_RU(id), 1);
			_uv2[numVertStart + 2 + 8] = float2(getLightB_LU(id), 1);
			_uv2[numVertStart + 3 + 8] = float2(getLightB_LD(id), 0);
		}
		//Neibour Back chank
		else if(id.z == 0){
		
		}
		else{
			for(int num = 0; num < 6; num++)
				_triangles[numTrianStart + num + 12] = 0;
		}
	}

	//Set Texture color
	_mainTexture[texturePos] = color;
}

bool isBlockExist(uint3 id){
	int index = id.z + id.y * 32 + id.x * 32 * 32;

	if(index >= 0 && _colors[index].w > 0.9f){
		return true;
	}

	return false;
}


float getlllumination(uint3 id){
	int index = id.z + id.y * 32 + id.x * 32 * 32;
	int indexMax = 32 * 32 * 32;


	if(id.x >= 0 && id.x < indexMax && 
		id.y >= 0 && id.y < indexMax &&
		id.z >= 0 && id.z < indexMax)
		return _lllumination[index];

	return 0.99f;
}

float getLightL_DB(uint3 id){

	uint3 posYmZ = uint3(id.x, id.y-1, id.z);
	uint3 posYmZm = uint3(id.x, id.y-1, id.z-1);
	uint3 posYZm = uint3(id.x, id.y, id.z - 1);

	bool YZ = isBlockExist(id);
	bool YmZ = isBlockExist(posYmZ);
	bool YmZm = isBlockExist(posYmZm);
	bool YZm = isBlockExist(posYZm);

	int count = 0;
	float lightSum = 0;

	if(!YZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!YmZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYmZ);
	}
	if(!YmZm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYmZm);
	}
	if(!YZm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYZm);
	}

	return lightSum/count;
}
float getLightL_UB(uint3 id){

	uint3 posYpZ = uint3(id.x, id.y+1, id.z);
	uint3 posYpZm = uint3(id.x, id.y+1, id.z-1);
	uint3 posYZm = uint3(id.x, id.y, id.z - 1);

	bool YZ = isBlockExist(id);
	bool YpZ = isBlockExist(posYpZ);
	bool YpZm = isBlockExist(posYpZm);
	bool YZm = isBlockExist(posYZm);

	int count = 0;
	float lightSum = 0;
	if(!YZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!YpZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYpZ);
	}
	if(!YpZm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYpZm);
	}
	if(!YZm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYZm);
	}

	return lightSum/count;
}
float getLightL_UF(uint3 id){

	uint3 posYpZ = uint3(id.x, id.y+1, id.z);
	uint3 posYpZp = uint3(id.x, id.y+1, id.z+1);
	uint3 posYZp = uint3(id.x, id.y, id.z + 1);

	bool YZ = isBlockExist(id);
	bool YpZ = isBlockExist(posYpZ);
	bool YpZp = isBlockExist(posYpZp);
	bool YZp = isBlockExist(posYZp);

	int count = 0;
	float lightSum = 0;
	if(!YZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!YpZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYpZ);
	}
	if(!YpZp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYpZp);
	}
	if(!YZp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYZp);
	}

	return lightSum/count;
}
float getLightL_DF(uint3 id){

	uint3 posYmZ = uint3(id.x, id.y-1, id.z);
	uint3 posYmZp = uint3(id.x, id.y-1, id.z+1);
	uint3 posYZp = uint3(id.x, id.y, id.z + 1);

	bool YZ = isBlockExist(id);
	bool YmZ = isBlockExist(posYmZ);
	bool YmZp = isBlockExist(posYmZp);
	bool YZp = isBlockExist(posYZp);

	int count = 0;
	float lightSum = 0;
	if(!YZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!YmZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYmZ);
	}
	if(!YmZp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYmZp);
	}
	if(!YZp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posYZp);
	}
	

	return lightSum/count;
}


float getLightD_LB(uint3 id){

	uint3 posXmZ = uint3(id.x-1, id.y, id.z);
	uint3 posXmZm = uint3(id.x-1, id.y, id.z-1);
	uint3 posXZm = uint3(id.x, id.y, id.z - 1);

	bool XZ = isBlockExist(id);
	bool XmZ = isBlockExist(posXmZ);
	bool XmZm = isBlockExist(posXmZm);
	bool XZm = isBlockExist(posXZm);

	int count = 0;
	float lightSum = 0;

	if(!XZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!XmZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXmZ);
	}
	if(!XmZm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXmZm);
	}
	if(!XZm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXZm);
	}

	return lightSum/count;
}
float getLightD_LF(uint3 id){

	uint3 posXmZ = uint3(id.x-1, id.y, id.z);
	uint3 posXmZp = uint3(id.x-1, id.y, id.z+1);
	uint3 posXZp = uint3(id.x, id.y, id.z + 1);

	bool XZ = isBlockExist(id);
	bool XmZ = isBlockExist(posXmZ);
	bool XmZp = isBlockExist(posXmZp);
	bool XZp = isBlockExist(posXZp);

	int count = 0;
	float lightSum = 0;

	if(!XZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!XmZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXmZ);
	}
	if(!XmZp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXmZp);
	}
	if(!XZp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXZp);
	}

	return lightSum/count;
}
float getLightD_RF(uint3 id){

	uint3 posXpZ = uint3(id.x+1, id.y, id.z);
	uint3 posXpZp = uint3(id.x+1, id.y, id.z+1);
	uint3 posXZp = uint3(id.x, id.y, id.z + 1);

	bool XZ = isBlockExist(id);
	bool XpZ = isBlockExist(posXpZ);
	bool XpZp = isBlockExist(posXpZp);
	bool XZp = isBlockExist(posXZp);

	int count = 0;
	float lightSum = 0;

	if(!XZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!XpZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXpZ);
	}
	if(!XpZp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXpZp);
	}
	if(!XZp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXZp);
	}

	return lightSum/count;
}
float getLightD_RB(uint3 id){

	uint3 posXpZ = uint3(id.x+1, id.y, id.z);
	uint3 posXpZm = uint3(id.x+1, id.y, id.z-1);
	uint3 posXZm = uint3(id.x, id.y, id.z - 1);

	bool XZ = isBlockExist(id);
	bool XpZ = isBlockExist(posXpZ);
	bool XpZm = isBlockExist(posXpZm);
	bool XZm = isBlockExist(posXZm);

	int count = 0;
	float lightSum = 0;

	if(!XZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!XpZ){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXpZ);
	}
	if(!XpZm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXpZm);
	}
	if(!XZm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXZm);
	}

	return lightSum/count;
}

float getLightB_LD(uint3 id){

	uint3 posXmY = uint3(id.x-1, id.y, id.z);
	uint3 posXmYm = uint3(id.x-1, id.y-1, id.z);
	uint3 posXYm = uint3(id.x, id.y-1, id.z);

	bool XY = isBlockExist(id);
	bool XmY = isBlockExist(posXmY);
	bool XmYm = isBlockExist(posXmYm);
	bool XYm = isBlockExist(posXYm);

	int count = 0;
	float lightSum = 0;

	if(!XY){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!XmY){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXmY);
	}
	if(!XmYm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXmYm);
	}
	if(!XYm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXYm);
	}

	return lightSum/count;
}
float getLightB_LU(uint3 id){

	uint3 posXmY = uint3(id.x-1, id.y, id.z);
	uint3 posXmYp = uint3(id.x-1, id.y+1, id.z);
	uint3 posXYp = uint3(id.x, id.y+1, id.z);

	bool XY = isBlockExist(id);
	bool XmY = isBlockExist(posXmY);
	bool XmYp = isBlockExist(posXmYp);
	bool XYp = isBlockExist(posXYp);

	int count = 0;
	float lightSum = 0;

	if(!XY){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!XmY){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXmY);
	}
	if(!XmYp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXmYp);
	}
	if(!XYp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXYp);
	}

	return lightSum/count;
}
float getLightB_RU(uint3 id){

	uint3 posXpY = uint3(id.x+1, id.y, id.z);
	uint3 posXpYp = uint3(id.x+1, id.y+1, id.z);
	uint3 posXYp = uint3(id.x, id.y+1, id.z);

	bool XY = isBlockExist(id);
	bool XpY = isBlockExist(posXpY);
	bool XpYp = isBlockExist(posXpYp);
	bool XYp = isBlockExist(posXYp);

	int count = 0;
	float lightSum = 0;

	if(!XY){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!XpY){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXpY);
	}
	if(!XpYp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXpYp);
	}
	if(!XYp){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXYp);
	}

	return lightSum/count;
}
float getLightB_RD(uint3 id){

	uint3 posXpY = uint3(id.x+1, id.y, id.z);
	uint3 posXpYm = uint3(id.x+1, id.y-1, id.z);
	uint3 posXYm = uint3(id.x, id.y-1, id.z);

	bool XY = isBlockExist(id);
	bool XpY = isBlockExist(posXpY);
	bool XpYm = isBlockExist(posXpYm);
	bool XYm = isBlockExist(posXYm);

	int count = 0;
	float lightSum = 0;

	if(!XY){
		count = count + 1;
		lightSum = lightSum + getlllumination(id);
	}
	if(!XpY){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXpY);
	}
	if(!XpYm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXpYm);
	}
	if(!XYm){
		count = count + 1;
		lightSum = lightSum + getlllumination(posXYm);
	}

	return lightSum/count;
}