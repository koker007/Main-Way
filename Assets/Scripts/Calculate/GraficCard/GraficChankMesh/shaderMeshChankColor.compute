// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWStructuredBuffer<float3> _vertices;
RWStructuredBuffer<float3> _normals;
RWStructuredBuffer<float2> _uv;
RWStructuredBuffer<float2> _uv2;
RWStructuredBuffer<int> _triangles;

RWStructuredBuffer<float4> _colors;
RWStructuredBuffer<float> _lllumination;


RWTexture2D<float4> _mainTexture;

int _mainTextureWight;
int _mainTextureHeight;

//Functions
void calcBlock(uint3 id);

void calcTriangles(uint3 id, int index);
void calcNormal(uint3 id, int index);

float getlllumination(uint3 id);

//Get light for point of side cube
float getLightL_DB(uint3 id);
float getLightL_UB(uint3 id);
float getLightL_UF(uint3 id);
float getLightL_DF(uint3 id);

float getLightD_LB(uint3 id);
float getLightD_LF(uint3 id);
float getLightD_RF(uint3 id);
float getLightD_RB(uint3 id);

float getLightB_LD(uint3 id);
float getLightB_LU(uint3 id);
float getLightB_RU(uint3 id);
float getLightB_RD(uint3 id);


[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	//check all 32 z positions
	for(uint z = 0; z < 32; z++){
		uint3 index = uint3(id.x, id.y, z);
		calcBlock(index);
	}
}

void calcBlock(uint3 id){

	//int indexMax = 32*32*32;

	//get global index
	int index = id.z + id.y * 32 + id.x * 32 * 32;

	int indexB = (id.z - 1) + id.y * 32 + id.x * 32 * 32;
	int indexD = id.z + (id.y - 1) * 32 + id.x * 32 * 32;
	int indexL = id.z + id.y * 32 + (id.x - 1) * 32 * 32;


	float4 color = _colors[index];

	//get color if Neibour exist
	float4 colorL = float4(0.0f, 0.0f, 0.0f, 0.0f);
	if(indexL >= 0){
		colorL = _colors[indexL];
	}
	float4 colorD = float4(0.0f, 0.0f, 0.0f, 0.0f);
	if(indexD >= 0){
		colorD = _colors[indexD];
	}
	float4 colorB = float4(0.0f, 0.0f, 0.0f, 0.0f);
	if(indexB >= 0){
		colorB = _colors[indexB];
	}

	int num = id.x + id.y * 32 + id.z * 32 * 32;
	int numVertStart = num * 4 * 3;
	int numTrianStart = num * 3 * 2 * 3;

	uint2 texturePos = uint2(num % _mainTextureWight, num / _mainTextureWight);
	float uvXsize = 1.0f / _mainTextureWight;
	float uvYsize = 1.0f / _mainTextureHeight;
	float uvXnow =  texturePos.x * uvXsize;
	float uvYnow =  texturePos.y * uvYsize;

	//for(int num = 0; num < 12; num++)
	//	_uv2[numVertStart + num] = float2(0.9f, 0);


	//Left, Down, Back
	if(color.w > 0.9f)
	{
		//Left
		if(indexL >= 0 && colorL.w <= 0.9f || indexL < 0){
			_triangles[numTrianStart + 0] = numVertStart;
			_triangles[numTrianStart + 1] = numVertStart + 3;
			_triangles[numTrianStart + 2] = numVertStart + 2;
			
			_triangles[numTrianStart + 3] = numVertStart + 2;
			_triangles[numTrianStart + 4] = numVertStart + 1;
			_triangles[numTrianStart + 5] = numVertStart;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num] = float3(-1.0f, 0.0f, 0.0f);

			_uv[numVertStart + 0] = float2(uvXnow, uvYnow);
			_uv[numVertStart + 1] = float2(uvXnow, uvYnow + uvYsize);
			_uv[numVertStart + 2] = float2(uvXnow + uvXsize, uvYnow + uvYsize);
			_uv[numVertStart + 3] = float2(uvXnow + uvXsize, uvYnow);

			float light = getlllumination(uint3(id.x - 1, id.y, id.z));
			_uv2[numVertStart + 0] = float2(light, 0);
			_uv2[numVertStart + 1] = float2(light, 1);
			_uv2[numVertStart + 2] = float2(light, 1);
			_uv2[numVertStart + 3] = float2(light, 0);
		}
		//Down
		if(indexD >= 0 && colorD.w <= 0.9f || indexD < 0){
			_triangles[numTrianStart + 6 + 0] = numVertStart + 4;
			_triangles[numTrianStart + 6 + 1] = numVertStart + 4 + 3;
			_triangles[numTrianStart + 6 + 2] = numVertStart + 4 + 2;
			
			_triangles[numTrianStart + 6 + 3] = numVertStart + 4 + 2;
			_triangles[numTrianStart + 6 + 4] = numVertStart + 4 + 1;
			_triangles[numTrianStart + 6 + 5] = numVertStart + 4;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num + 4] = float3(0.0f, -1.0f, 0.0f);

			_uv[numVertStart + 0 + 4] = float2(uvXnow, uvYnow);
			_uv[numVertStart + 1 + 4] = float2(uvXnow, uvYnow + uvYsize);
			_uv[numVertStart + 2 + 4] = float2(uvXnow + uvXsize, uvYnow + uvYsize);
			_uv[numVertStart + 3 + 4] = float2(uvXnow + uvXsize, uvYnow);

			float light = getlllumination(uint3(id.x, id.y - 1, id.z));
			_uv2[numVertStart + 0 + 4] = float2(light, 0);
			_uv2[numVertStart + 1 + 4] = float2(light, 1);
			_uv2[numVertStart + 2 + 4] = float2(light, 1);
			_uv2[numVertStart + 3 + 4] = float2(light, 0);
		}
		//Back
		if(indexB >= 0 && colorB.w <= 0.9f || indexB < 0){
			_triangles[numTrianStart + 12 + 0] = numVertStart + 8;
			_triangles[numTrianStart + 12 + 1] = numVertStart + 8 + 3;
			_triangles[numTrianStart + 12 + 2] = numVertStart + 8 + 2;

			_triangles[numTrianStart + 12 + 3] = numVertStart + 8 + 2;
			_triangles[numTrianStart + 12 + 4] = numVertStart + 8 + 1;
			_triangles[numTrianStart + 12 + 5] = numVertStart + 8;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num + 8] = float3(0.0f, 0.0f, -1.0f);

			_uv[numVertStart + 0 + 8] = float2(uvXnow, uvYnow);
			_uv[numVertStart + 1 + 8] = float2(uvXnow, uvYnow + uvYsize);
			_uv[numVertStart + 2 + 8] = float2(uvXnow + uvXsize, uvYnow + uvYsize);
			_uv[numVertStart + 3 + 8] = float2(uvXnow + uvXsize, uvYnow);

			float light = getlllumination(uint3(id.x, id.y, id.z - 1));
			_uv2[numVertStart + 0 + 8] = float2(light, 0);
			_uv2[numVertStart + 1 + 8] = float2(light, 1);
			_uv2[numVertStart + 2 + 8] = float2(light, 1);
			_uv2[numVertStart + 3 + 8] = float2(light, 0);
		}

	}
	//Neibour
	else{
		//Left
		if(id.x > 0 && colorL.w > 0.9f){
			_triangles[numTrianStart + 0] = numVertStart;
			_triangles[numTrianStart + 1] = numVertStart + 1;
			_triangles[numTrianStart + 2] = numVertStart + 2;

			_triangles[numTrianStart + 3] = numVertStart + 2;
			_triangles[numTrianStart + 4] = numVertStart + 3;
			_triangles[numTrianStart + 5] = numVertStart;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num] = float3(1.0f, 0.0f, 0.0f);

			int numL = (id.x-1) + id.y * 32 + id.z * 32 * 32;
			uint2 texturePosL = uint2(numL % _mainTextureWight, numL / _mainTextureWight);
			float uvXL =  texturePosL.x * uvXsize;
			float uvYL =  texturePosL.y * uvYsize;
			_uv[numVertStart + 0] = float2(uvXL, uvYL);
			_uv[numVertStart + 1] = float2(uvXL, uvYL + uvYsize);
			_uv[numVertStart + 2] = float2(uvXL + uvXsize, uvYL + uvYsize);
			_uv[numVertStart + 3] = float2(uvXL + uvXsize, uvYL);

			float light = getlllumination(uint3(id.x, id.y, id.z));
			_uv2[numVertStart + 0] = float2(light, 0);
			_uv2[numVertStart + 1] = float2(light, 1);
			_uv2[numVertStart + 2] = float2(light, 1);
			_uv2[numVertStart + 3] = float2(light, 0);
		}
		//Neibour Left chank
		else if(id.x == 0){
		
		}
		else{
			for(int num = 0; num < 6; num++)
				_triangles[numTrianStart + num] = 0;
		}
		//Down
		if(id.y > 0 && colorD.w > 0.9f){
			_triangles[numTrianStart + 6 + 0] = numVertStart + 4;
			_triangles[numTrianStart + 6 + 1] = numVertStart + 4 + 1;
			_triangles[numTrianStart + 6 + 2] = numVertStart + 4 + 2;
			
			_triangles[numTrianStart + 6 + 3] = numVertStart + 4 + 2;
			_triangles[numTrianStart + 6 + 4] = numVertStart + 4 + 3;
			_triangles[numTrianStart + 6 + 5] = numVertStart + 4;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num + 4] = float3(0.0f, 1.0f, 0.0f);

			int numD = id.x + (id.y-1) * 32 + id.z * 32 * 32;
			uint2 texturePosL = uint2(numD % _mainTextureWight, numD / _mainTextureWight);
			float uvXD =  texturePosL.x * uvXsize;
			float uvYD =  texturePosL.y * uvYsize;
			_uv[numVertStart + 0 + 4] = float2(uvXD, uvYD);
			_uv[numVertStart + 1 + 4] = float2(uvXD, uvYD + uvYsize);
			_uv[numVertStart + 2 + 4] = float2(uvXD + uvXsize, uvYD + uvYsize);
			_uv[numVertStart + 3 + 4] = float2(uvXD + uvXsize, uvYD);

			float light = getlllumination(uint3(id.x, id.y, id.z));
			_uv2[numVertStart + 0 + 4] = float2(light, 0);
			_uv2[numVertStart + 1 + 4] = float2(light, 1);
			_uv2[numVertStart + 2 + 4] = float2(light, 1);
			_uv2[numVertStart + 3 + 4] = float2(light, 0);
		}
		//Neibour Down chank
		else if(id.y == 0){
		
		}
		else{
			for(int num = 0; num < 6; num++)
				_triangles[numTrianStart + num + 6] = 0;
		}

		//Back
		if(id.z > 0 && colorB.w > 0.9f){
			_triangles[numTrianStart + 12 + 0] = numVertStart + 8;
			_triangles[numTrianStart + 12 + 1] = numVertStart + 8 + 1;
			_triangles[numTrianStart + 12 + 2] = numVertStart + 8 + 2;

			_triangles[numTrianStart + 12 + 3] = numVertStart + 8 + 2;
			_triangles[numTrianStart + 12 + 4] = numVertStart + 8 + 3;
			_triangles[numTrianStart + 12 + 5] = numVertStart + 8;

			for(int num = 0; num < 4; num++)
				_normals[numVertStart + num + 8] = float3(0.0f, 0.0f, 1.0f);

			int numB = id.x + id.y * 32 + (id.z-1) * 32 * 32;
			uint2 texturePosL = uint2(numB % _mainTextureWight, numB / _mainTextureWight);
			float uvXB =  texturePosL.x * uvXsize;
			float uvYB =  texturePosL.y * uvYsize;
			_uv[numVertStart + 0 + 8] = float2(uvXB, uvYB);
			_uv[numVertStart + 1 + 8] = float2(uvXB, uvYB + uvYsize);
			_uv[numVertStart + 2 + 8] = float2(uvXB + uvXsize, uvYB + uvYsize);
			_uv[numVertStart + 3 + 8] = float2(uvXB + uvXsize, uvYB);

			float light = getlllumination(uint3(id.x, id.y, id.z));
			_uv2[numVertStart + 0 + 8] = float2(light, 0);
			_uv2[numVertStart + 1 + 8] = float2(light, 1);
			_uv2[numVertStart + 2 + 8] = float2(light, 1);
			_uv2[numVertStart + 3 + 8] = float2(light, 0);
		}
		//Neibour Back chank
		else if(id.z == 0){
		
		}
		else{
			for(int num = 0; num < 6; num++)
				_triangles[numTrianStart + num + 12] = 0;
		}
	}

	//Set Texture color
	_mainTexture[texturePos] = color;
}


float getlllumination(uint3 id){
	int index = id.z + id.y * 32 + id.x * 32 * 32;

	if(index >= 0)
		return _lllumination[index];

	return 0.99f;
}