// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

int sizeShader;


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct Data{
    float result;
};

RWStructuredBuffer<Data> datas;

float _offsetX;
float _offsetY;
float _offsetZ;
float _factor;
float _factorX;
float _factorY;
float _factorZ;
float _frequency;
float _octaves;

int _repeatX;
int _repeatY; //if repeat zero is off //repeat in pixels
float _regionX; //from 0 to 1 region texture
float _regionY; //from 0 to 1 region texture

float _value;

int _ArrayMax;

float perlin(float3 p, float frequency);
float map(int idX, int idY, int arrayNum);
float map2(int idX, int idY, int arrayNum);

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
     
     for(int arrayNum = 0; arrayNum < _ArrayMax; arrayNum++){

         float dataID = 32*id.x*_ArrayMax + id.y*_ArrayMax + arrayNum;

         float dataMap = map(id.x, id.y, arrayNum);


         datas[dataID].result = dataMap;
     }
}

float perlin(float3 p, float frequency)
{

    float freq = frequency;
    float result = 0;

    for (int _octNum = 0; _octNum < _octaves; _octNum++)
    {

        float3 i = floor(p * freq);
        float3 f = frac(p * freq);
        float3 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
        //plant of UP
        float3 a = i + float3(0.0, 0.0, 0.0);
        float3 b = i + float3(1.0, 0.0, 0.0);
        float3 c = i + float3(0.0, 1.0, 0.0);
        float3 d = i + float3(1.0, 1.0, 0.0);

        float3 az = i + float3(0.0, 0.0, 1.0);
        float3 bz = i + float3(1.0, 0.0, 1.0);
        float3 cz = i + float3(0.0, 1.0, 1.0);
        float3 dz = i + float3(1.0, 1.0, 1.0);

        a = -1.0 + 2.0 * frac(sin( float3(dot(a, float3(127.1, 311.7, 233.5)), dot(a, float3(269.5, 183.3, 351.9)), dot(a, float3(111.1, 346.7, 59.1)))) *43758.5453123);
        b = -1.0 + 2.0 * frac(sin( float3(dot(b, float3(127.1, 311.7, 233.5)), dot(b, float3(269.5, 183.3, 351.9)), dot(b, float3(111.1, 346.7, 59.1)))) *43758.5453123);
        c = -1.0 + 2.0 * frac(sin( float3(dot(c, float3(127.1, 311.7, 233.5)), dot(c, float3(269.5, 183.3, 351.9)), dot(c, float3(111.1, 346.7, 59.1)))) *43758.5453123);
        d = -1.0 + 2.0 * frac(sin( float3(dot(d, float3(127.1, 311.7, 233.5)), dot(d, float3(269.5, 183.3, 351.9)), dot(d, float3(111.1, 346.7, 59.1)))) *43758.5453123);

        az = -1.0 + 2.0 * frac(sin(float3(dot(az, float3(127.1, 311.7, 233.5)), dot(az, float3(269.5, 183.3, 351.9)), dot(az, float3(111.1, 346.7, 59.1)))) * 43758.5453123);
        bz = -1.0 + 2.0 * frac(sin(float3(dot(bz, float3(127.1, 311.7, 233.5)), dot(bz, float3(269.5, 183.3, 351.9)), dot(bz, float3(111.1, 346.7, 59.1)))) * 43758.5453123);
        cz = -1.0 + 2.0 * frac(sin(float3(dot(cz, float3(127.1, 311.7, 233.5)), dot(cz, float3(269.5, 183.3, 351.9)), dot(cz, float3(111.1, 346.7, 59.1)))) * 43758.5453123);
        dz = -1.0 + 2.0 * frac(sin(float3(dot(dz, float3(127.1, 311.7, 233.5)), dot(dz, float3(269.5, 183.3, 351.9)), dot(dz, float3(111.1, 346.7, 59.1)))) * 43758.5453123);

        float A = dot(a, f - float3(0.0, 0.0, 0.0));
        float B = dot(b, f - float3(1.0, 0.0, 0.0));
        float C = dot(c, f - float3(0.0, 1.0, 0.0));
        float D = dot(d, f - float3(1.0, 1.0, 0.0));

        float Az = dot(az, f - float3(0.0, 0.0, 1.0));
        float Bz = dot(bz, f - float3(1.0, 0.0, 1.0));
        float Cz = dot(cz, f - float3(0.0, 1.0, 1.0));
        float Dz = dot(dz, f - float3(1.0, 1.0, 1.0));

        float noiseXY =lerp(lerp(A, B, t.x), lerp(C, D, t.x), t.y);
        float noiseZ = lerp(lerp(Az, Bz, t.x), lerp(Cz, Dz, t.x), t.y);

        float noise = lerp(noiseXY, noiseZ, t.z);

        noise /= (_octNum*4.0f + 1.0f);

        result += noise;

        freq *= 2.0f;

    }
    result = result / 2 + 0.5f;

    result = clamp(result, 0, 1.0);

    return result;
}

float map(int idX, int idY, int arrayNum){

    //Need calc perlin

    //1 Grid definition
    
    
    //2 dot product
    
    
    //3 interpolation

    float x = _factorX * idX + _offsetX;
    float y = _factorY * idY + _offsetY;
    float z = arrayNum * 74603.16627f + _offsetZ;

    float pixelXCoofRegion = 1.0f / _repeatX;
    float pixelYCoofRegion = 1.0f / _repeatY;
    float regionXNow = _regionX + pixelXCoofRegion * idX;
    float regionYNow = _regionY + pixelYCoofRegion * idY;

    float3 posNormal = float3(x, y, z);
    float3 posMinusSizeX = float3(x - _repeatX*_factorX, y, z);

    float perlinNormal = perlin(posNormal, _frequency);
    float perlinMinusSizeX = perlin(posMinusSizeX, _frequency);

    float perlinBlendX = (perlinNormal *  (1 - regionXNow)) + (perlinMinusSizeX * regionXNow);

    //blend size/2
    float x05 = x;
    float x05M = x - _repeatX*_factorX;

    if(regionXNow > 0.5f){
       x05 -= (_repeatX*_factorX/2);
       x05M -= (_repeatX*_factorX/2);
    }
    else {
        x05 += (_repeatX*_factorX/2);
        x05M += (_repeatX*_factorX/2);
    }

    float3 posMinusSize05X = float3(x05, y, z);
    float3 posPlusSize05X = float3(x05M, y, z);

    float perlinMinusSize05X = perlin(posMinusSize05X, _frequency);
    float perlinPlusSize05X = perlin(posPlusSize05X, _frequency);

    float blendCoof05 = regionXNow - 0.5f;
    if(blendCoof05 <= 0)
        blendCoof05 += 1.0f;

    float perlinBlend05X = (perlinPlusSize05X *  blendCoof05) + (perlinMinusSize05X * (1 - blendCoof05));

    float intensiveY = 0;

    float polus = 0.5f;
    if(regionYNow < polus){
        intensiveY = (1 - (regionYNow/polus))/2;
    }
    else if(regionYNow > 1 - polus){
        intensiveY = (1-((1 - regionYNow)/polus))/2;
    }

    float perlinBlendY = (perlinBlendX *  (1 - intensiveY)) + (perlinBlend05X * intensiveY);

    return perlinBlendY;

}

float map2(int idX, int idY, int arrayNum){

    //Need calc perlin

    //1 Grid definition
    
    
    //2 dot product
    
    
    //3 interpolation

    float x = _factorX * idX + _offsetX;
    float y = _factorY * idY + _offsetY;
    float z = arrayNum * 74603.16627f + _offsetZ;

    float pixelXCoofRegion = 1.0f / _repeatX;
    float pixelYCoofRegion = 1.0f / _repeatY;
    float regionXNow = _regionX + pixelXCoofRegion * idX;
    float regionYNow = _regionY + pixelYCoofRegion * idY;

    //N - normal //M - minus
    float3 posNxNy = float3(x, y, z);
    float3 posMxNy = float3(x - _repeatX*_factorX, y, z);
    float3 posNxMy = float3(x, y - _repeatY*_factorY, z);
    float3 posMxMy = float3(x - _repeatX*_factorX, y - _repeatY*_factorY, z);

    float perlinNxNy = perlin(posNxNy, _frequency);
    float perlinMxNy = perlin(posMxNy, _frequency);
    float perlinNxMy = perlin(posNxMy, _frequency);
    float perlinMxMy = perlin(posMxMy, _frequency);

    float perlinBlendXNy = (perlinNxNy *  (1 - regionXNow)) + (perlinMxNy * regionXNow);
    float perlinBlendXMy = (perlinNxMy *  (1 - regionXNow)) + (perlinMxMy * regionXNow);

    float perlinBlendY = (perlinBlendXNy *  (1 - regionYNow)) + (perlinBlendXMy * regionYNow);

    return perlinBlendY;

}
