// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct Voxel{
    float height;
};
struct Vec3{
    float x;
    float y;
    float z;
};

struct Integer{
    uint num;
};

struct TexUV{
    float u;
    float v;
};



RWStructuredBuffer<Vec3> _vertices;
RWStructuredBuffer<Integer> _triangles;
RWStructuredBuffer<TexUV> _uv;
RWStructuredBuffer<Vec3> _normals;

RWStructuredBuffer<Integer> _exist;

//Functions
void calcVoxel(uint3 id);

bool isExistVoxel(int VoxID);
bool isExistVoxFace(int voxID, uint3 id);
bool isExistVoxLeft(int voxID, uint3 id);
bool isExistVoxDown(int voxID, uint3 id);

void calcVertex(uint vertStart, uint3 id);

void testLeft(int voxID, uint vert, uint triangleStart, uint3 id);
void testDown(int voxID, uint vert, uint triangleStart, uint3 id);
void testFace(int voxID, uint vert, uint triangleStart, uint3 id);

[numthreads(8,8,16)]
void CSMain (uint3 id : SV_DispatchThreadID)
{   
    id = uint3(id.x * 2, id.y * 2, id.z);
    
    uint3 idLD = uint3(id.x, id.y, id.z);
    uint3 idRD = uint3(id.x + 1, id.y, id.z);
    uint3 idLU = uint3(id.x, id.y + 1, id.z);
    uint3 idRU = uint3(id.x + 1, id.y + 1, id.z);

    calcVoxel(idLD);
    calcVoxel(idRD);

    calcVoxel(idLU);
    calcVoxel(idRU);
}

void calcVoxel(uint3 id){

    int voxID = (id.x) + (id.y * 16) + (id.z * 16 * 16); //4095

    //3 = side
    //2 = triangles
    //3 = points
    uint vertCount = 3*4; //24
    uint trianCount = 3 * 2 * 3; //3 point on triangle, 2 triangles on side, 3 side //18

    uint vertStart = vertCount * voxID; //98280
    uint trianStart = trianCount * voxID; //73710

    calcVertex(vertStart, id);

    testLeft(voxID, vertStart, trianStart, id);
    testDown(voxID, vertStart, trianStart, id);
    testFace(voxID, vertStart, trianStart, id);
}

bool isExistVoxel(int voxID){
    int voxIDMax = 16*16*16;

    if(voxID >= 0 && voxID < voxIDMax && _exist[voxID].num == 1){
        return true;
    }

    return false;
}

bool isExistVoxFace(int voxID, uint3 id){
    if(id.z == 0){
        return false;    
    }

    int voxIDf = voxID - 256;

    return isExistVoxel(voxIDf);
}
bool isExistVoxLeft(int voxID, uint3 id){
    if(id.x == 0){
        return false;    
    }

    int voxIDl = voxID - 1;

    return isExistVoxel(voxIDl);
}
bool isExistVoxDown(int voxID, uint3 id){
    if(id.y == 0){
        return false;    
    }

    int voxIDd = voxID - 16;

    return isExistVoxel(voxIDd);
}

void calcVertex(uint vert, uint3 id){
    float sizeVoxel = 1/16.0f;

    float sizeTexelU = 1/(16.0f*16.0f);
    float sizeTexelV = 1/16.0f;

    float posX = id.x * sizeVoxel;
    float posY = id.y * sizeVoxel;
    float posZ = id.z * sizeVoxel;

    //Left
    _vertices[vert + 4 * 0 + 0].x = posX;
    _vertices[vert + 4 * 0 + 0].y = posY;
    _vertices[vert + 4 * 0 + 0].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 0 + 1].x = posX;
    _vertices[vert + 4 * 0 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 0 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 0 + 2].x = posX;
    _vertices[vert + 4 * 0 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 0 + 2].z = posZ;

    _vertices[vert + 4 * 0 + 3].x = posX;
    _vertices[vert + 4 * 0 + 3].y = posY;
    _vertices[vert + 4 * 0 + 3].z = posZ;

    //Down
    _vertices[vert + 4 * 1 + 0].x = posX + sizeVoxel;
    _vertices[vert + 4 * 1 + 0].y = posY;
    _vertices[vert + 4 * 1 + 0].z = posZ;

    _vertices[vert + 4 * 1 + 1].x = posX + sizeVoxel;
    _vertices[vert + 4 * 1 + 1].y = posY;
    _vertices[vert + 4 * 1 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 1 + 2].x = posX;
    _vertices[vert + 4 * 1 + 2].y = posY;
    _vertices[vert + 4 * 1 + 2].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 1 + 3].x = posX;
    _vertices[vert + 4 * 1 + 3].y = posY;
    _vertices[vert + 4 * 1 + 3].z = posZ;

    //Face
    _vertices[vert + 4 * 2 + 0].x = posX;
    _vertices[vert + 4 * 2 + 0].y = posY;
    _vertices[vert + 4 * 2 + 0].z = posZ;

    _vertices[vert + 4 * 2 + 1].x = posX;
    _vertices[vert + 4 * 2 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 2 + 1].z = posZ;

    _vertices[vert + 4 * 2 + 2].x = posX + sizeVoxel;
    _vertices[vert + 4 * 2 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 2 + 2].z = posZ;

    _vertices[vert + 4 * 2 + 3].x = posX + sizeVoxel;
    _vertices[vert + 4 * 2 + 3].y = posY;
    _vertices[vert + 4 * 2 + 3].z = posZ;

    //normals
    for(int num = 0; num < 4; num++){
        _normals[vert + 4 * 0 + num].x = -1.0f;
        _normals[vert + 4 * 0 + num].y = 0.0f;
        _normals[vert + 4 * 0 + num].z = 0.0f;

        _normals[vert + 4 * 1 + num].x = 0.0f;
        _normals[vert + 4 * 1 + num].y = -1.0f;
        _normals[vert + 4 * 1 + num].z = 0.0f;

        _normals[vert + 4 * 2 + num].x = 0.0f;
        _normals[vert + 4 * 2 + num].y = 0.0f;
        _normals[vert + 4 * 2 + num].z = -1.0f;
    }

    for(int num = 0; num < 4 * 3; num++){
        _uv[vert + num].u = id.x * sizeTexelU + sizeTexelU/2 + id.z * 16 * sizeTexelU;
        _uv[vert + num].v = id.y * sizeTexelV + sizeTexelV/2;
    }

    //Right
    if(id.x == 15){
        uint vertStart = (16*16*16*3 + 16*16*0 + id.z + id.y * 16)*4;
        _vertices[vertStart + 0].x = posX + sizeVoxel;
        _vertices[vertStart + 0].y = posY;
        _vertices[vertStart + 0].z = posZ;

        _vertices[vertStart + 1].x = posX + sizeVoxel;
        _vertices[vertStart + 1].y = posY + sizeVoxel;
        _vertices[vertStart + 1].z = posZ;

        _vertices[vertStart + 2].x = posX + sizeVoxel;
        _vertices[vertStart + 2].y = posY + sizeVoxel;
        _vertices[vertStart + 2].z = posZ + sizeVoxel;

        _vertices[vertStart + 3].x = posX + sizeVoxel;
        _vertices[vertStart + 3].y = posY;
        _vertices[vertStart + 3].z = posZ + sizeVoxel;

        for(int num = 0; num < 4; num++){
            _normals[vertStart + num].x = 1.0f;
            _normals[vertStart + num].y = 0.0f;
            _normals[vertStart + num].z = 0.0f;
        }

        for(int num = 0; num < 4; num++){
            _uv[vertStart + num].u = id.x * sizeTexelU + sizeTexelU/2 + id.z * 16 * sizeTexelU;
            _uv[vertStart + num].v = id.y * sizeTexelV + sizeTexelV/2;
        }
    }
    //UP
    if(id.y == 15){
        uint vertStart = (16*16*16*3 + 16*16*1 + id.x + id.z * 16)*4;
        _vertices[vertStart + 0].x = posX;
        _vertices[vertStart + 0].y = posY + sizeVoxel;
        _vertices[vertStart + 0].z = posZ;

        _vertices[vertStart + 1].x = posX;
        _vertices[vertStart + 1].y = posY + sizeVoxel;
        _vertices[vertStart + 1].z = posZ + sizeVoxel;

        _vertices[vertStart + 2].x = posX + sizeVoxel;
        _vertices[vertStart + 2].y = posY + sizeVoxel;
        _vertices[vertStart + 2].z = posZ + sizeVoxel;

        _vertices[vertStart + 3].x = posX + sizeVoxel;
        _vertices[vertStart + 3].y = posY + sizeVoxel;
        _vertices[vertStart + 3].z = posZ;

        for(int num = 0; num < 4; num++){
            _normals[vertStart + num].x = 0.0f;
            _normals[vertStart + num].y = 1.0f;
            _normals[vertStart + num].z = 0.0f;
        }

        for(int num = 0; num < 4; num++){
            _uv[vertStart + num].u = id.x * sizeTexelU + sizeTexelU/2 + id.z * 16 * sizeTexelU;
            _uv[vertStart + num].v = id.y * sizeTexelV + sizeTexelV/2;
        }
    }
    //back
    if(id.z == 15){
        uint vertStart = (16*16*16*3 + 16*16*2 + id.x + id.y * 16)*4;
        _vertices[vertStart + 0].x = posX + sizeVoxel;
        _vertices[vertStart + 0].y = posY;
        _vertices[vertStart + 0].z = posZ + sizeVoxel;

        _vertices[vertStart + 1].x = posX + sizeVoxel;
        _vertices[vertStart + 1].y = posY + sizeVoxel;
        _vertices[vertStart + 1].z = posZ + sizeVoxel;

        _vertices[vertStart + 2].x = posX;
        _vertices[vertStart + 2].y = posY + sizeVoxel;
        _vertices[vertStart + 2].z = posZ + sizeVoxel;

        _vertices[vertStart + 3].x = posX;
        _vertices[vertStart + 3].y = posY;
        _vertices[vertStart + 3].z = posZ + sizeVoxel;

        for(int num = 0; num < 4; num++){
            _normals[vertStart + num].x = 0.0f;
            _normals[vertStart + num].y = 0.0f;
            _normals[vertStart + num].z = 1.0f;
        }

        for(int num = 0; num < 4; num++){
            _uv[vertStart + num].u = id.x * sizeTexelU + sizeTexelU/2 + id.z * 16 * sizeTexelU;
            _uv[vertStart + num].v = id.y * sizeTexelV + sizeTexelV/2;
        }
    }
}


void testLeft(int voxID, uint vert, uint triangleStart, uint3 id){
    
    if(isExistVoxel(voxID) && !isExistVoxLeft(voxID, id)){

        _triangles[triangleStart + 0 + 6*0].num = vert + 4 * 0 + 0;
        _triangles[triangleStart + 1 + 6*0].num = vert + 4 * 0 + 1;
        _triangles[triangleStart + 2 + 6*0].num = vert + 4 * 0 + 2;

        _triangles[triangleStart + 3 + 6*0].num = vert + 4 * 0 + 2;
        _triangles[triangleStart + 4 + 6*0].num = vert + 4 * 0 + 3;
        _triangles[triangleStart + 5 + 6*0].num = vert + 4 * 0 + 0;

        
    }
    else if(!isExistVoxel(voxID) && isExistVoxLeft(voxID, id) && id.x != 0){

        _triangles[triangleStart + 0 + 6*0].num = vert + 4 * 0 + 0;
        _triangles[triangleStart + 1 + 6*0].num = vert + 4 * 0 + 3;
        _triangles[triangleStart + 2 + 6*0].num = vert + 4 * 0 + 2;

        _triangles[triangleStart + 3 + 6*0].num = vert + 4 * 0 + 2;
        _triangles[triangleStart + 4 + 6*0].num = vert + 4 * 0 + 1;
        _triangles[triangleStart + 5 + 6*0].num = vert + 4 * 0 + 0;

        for(int num = 0; num < 4; num++){
            _normals[vert + 4 * 0 + num].x = 1.0f;
            _normals[vert + 4 * 0 + num].y = 0.0f;
            _normals[vert + 4 * 0 + num].z = 0.0f;
        }

        float sizeTexelU = 1/(16.0f*16.0f);
        float sizeTexelV = 1/16.0f;
        for(int num = 0; num < 4; num++){
            _uv[vert + num].u = id.x * sizeTexelU + sizeTexelU/2 + id.z * 16 * sizeTexelU - (sizeTexelU);
            _uv[vert + num].v = id.y * sizeTexelV + sizeTexelV/2;
        }
    }
    else{
        for(int num = 0; num < 6; num++){
            _triangles[triangleStart + num + 6*0].num = 0;
        }
    }

    //Last right side
    int triangleLast = (16*16*16*3 + 16*16*0 + id.z + id.y*16)*2*3;
    int vertexLast = (16*16*16*3 + 16*16*0 + id.z + id.y*16)*4;
    if(id.x != 15 || !isExistVoxel(voxID)){
        return;
    }
    else{
        _triangles[triangleLast + 0].num = vertexLast + 0;
        _triangles[triangleLast + 1].num = vertexLast + 1;
        _triangles[triangleLast + 2].num = vertexLast + 2;

        _triangles[triangleLast + 3].num = vertexLast + 2;
        _triangles[triangleLast + 4].num = vertexLast + 3;
        _triangles[triangleLast + 5].num = vertexLast + 0;
    }
}

void testDown(int voxID, uint vert, uint triangleStart, uint3 id){

    if(isExistVoxel(voxID) && !isExistVoxDown(voxID, id)){
        //Down
        _triangles[triangleStart + 0 + 6*1].num = vert + 4 * 1 + 0;
        _triangles[triangleStart + 1 + 6*1].num = vert + 4 * 1 + 1;
        _triangles[triangleStart + 2 + 6*1].num = vert + 4 * 1 + 2;

        _triangles[triangleStart + 3 + 6*1].num = vert + 4 * 1 + 2;
        _triangles[triangleStart + 4 + 6*1].num = vert + 4 * 1 + 3;
        _triangles[triangleStart + 5 + 6*1].num = vert + 4 * 1 + 0;
    }
    else if(!isExistVoxel(voxID) && isExistVoxDown(voxID, id) && id.y != 0){
        //up
        _triangles[triangleStart + 0 + 6*1].num = vert + 4 * 1 + 0;
        _triangles[triangleStart + 1 + 6*1].num = vert + 4 * 1 + 3;
        _triangles[triangleStart + 2 + 6*1].num = vert + 4 * 1 + 2;

        _triangles[triangleStart + 3 + 6*1].num = vert + 4 * 1 + 2;
        _triangles[triangleStart + 4 + 6*1].num = vert + 4 * 1 + 1;
        _triangles[triangleStart + 5 + 6*1].num = vert + 4 * 1 + 0;

        for(int num = 0; num < 4; num++){
            _normals[vert + 4 * 1 + num].x = 0.0f;
            _normals[vert + 4 * 1 + num].y = 1.0f;
            _normals[vert + 4 * 1 + num].z = 0.0f;
        }

        float sizeTexelU = 1/(16.0f*16.0f);
        float sizeTexelV = 1/16.0f;

        for(int num = 0; num < 4; num++){
            _uv[vert + 4 * 1 + num].u = id.x * sizeTexelU + sizeTexelU/2 + id.z * 16 * sizeTexelU;
            _uv[vert + 4 * 1 + num].v = id.y * sizeTexelV + sizeTexelV/2 - sizeTexelV;
        }
    }
    else{
        for(int num = 0; num < 6; num++){
            _triangles[triangleStart + num + 6*1].num = 0;
        }
    }

    //Last up side
    int triangleLast = (16*16*16*3 + 16*16*1 + id.x + id.z*16)*2*3;
    int vertexLast = (16*16*16*3 + 16*16*1 + id.x + id.z*16)*4;
    if(id.y != 15 || !isExistVoxel(voxID)){
        return;
    }
    else{
        _triangles[triangleLast + 0 + 6*2].num = vertexLast + 0;
        _triangles[triangleLast + 1 + 6*2].num = vertexLast + 1;
        _triangles[triangleLast + 2 + 6*2].num = vertexLast + 2;

        _triangles[triangleLast + 3 + 6*2].num = vertexLast + 2;
        _triangles[triangleLast + 4 + 6*2].num = vertexLast + 3;
        _triangles[triangleLast + 5 + 6*2].num = vertexLast + 0;
    }
}

void testFace(int voxID, uint vert, uint triangleStart, uint3 id){

    if(isExistVoxel(voxID) && !isExistVoxFace(voxID, id)){
        //face
        _triangles[triangleStart + 0 + 6*2].num = vert + 4 * 2 + 0;
        _triangles[triangleStart + 1 + 6*2].num = vert + 4 * 2 + 1;
        _triangles[triangleStart + 2 + 6*2].num = vert + 4 * 2 + 2;

        _triangles[triangleStart + 3 + 6*2].num = vert + 4 * 2 + 2;
        _triangles[triangleStart + 4 + 6*2].num = vert + 4 * 2 + 3;
        _triangles[triangleStart + 5 + 6*2].num = vert + 4 * 2 + 0;
    }
    else if(!isExistVoxel(voxID) && isExistVoxFace(voxID, id) && id.z != 0){
        //back
        _triangles[triangleStart + 0 + 6*2].num = vert + 4 * 2 + 0;
        _triangles[triangleStart + 1 + 6*2].num = vert + 4 * 2 + 3;
        _triangles[triangleStart + 2 + 6*2].num = vert + 4 * 2 + 2;

        _triangles[triangleStart + 3 + 6*2].num = vert + 4 * 2 + 2;
        _triangles[triangleStart + 4 + 6*2].num = vert + 4 * 2 + 1;
        _triangles[triangleStart + 5 + 6*2].num = vert + 4 * 2 + 0;

        for(int num = 0; num < 4; num++){
            _normals[vert + 4 * 2 + num].x = 0.0f;
            _normals[vert + 4 * 2 + num].y = 0.0f;
            _normals[vert + 4 * 2 + num].z = 1.0f;
        }

        float sizeTexelU = 1/(16.0f*16.0f);
        float sizeTexelV = 1/16.0f;

        for(int num = 0; num < 4; num++){
            _uv[vert + 4 * 2 + num].u = id.x * sizeTexelU + sizeTexelU/2 + id.z * 16 * sizeTexelU - (16 * sizeTexelU);
            _uv[vert + 4 * 2 + num].v = id.y * sizeTexelV + sizeTexelV/2;
        }
    }
    else{
        for(int num = 0; num < 6; num++){
            _triangles[triangleStart + num + 6*2].num = 0;
        }
    }


    //Last back side
    int triangleLast = (16*16*16*3 + 16*16*2 + id.x + id.y*16)*2*3;
    int vertexLast = (16*16*16*3 + 16*16*2 + id.x + id.y*16)*4;
    if(id.z != 15 || !isExistVoxel(voxID)){
        return;
    }
    else{
        _triangles[triangleLast + 0].num = vertexLast + 0;
        _triangles[triangleLast + 1].num = vertexLast + 1;
        _triangles[triangleLast + 2].num = vertexLast + 2;

        _triangles[triangleLast + 3].num = vertexLast + 2;
        _triangles[triangleLast + 4].num = vertexLast + 3;
        _triangles[triangleLast + 5].num = vertexLast + 0;
    }
}