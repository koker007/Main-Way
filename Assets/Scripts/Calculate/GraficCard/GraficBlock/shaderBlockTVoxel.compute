// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct Voxel{
    float height;
};
struct Vec3{
    float x;
    float y;
    float z;
};

struct Integer{
    int num;
};

struct TexUV{
    float u;
    float v;
};



RWStructuredBuffer<Vec3> _vertices;
RWStructuredBuffer<Integer> _triangles;
RWStructuredBuffer<TexUV> _uv;
RWStructuredBuffer<Vec3> _normals;

RWStructuredBuffer<Integer> _exist;

//Functions
void calcSector(uint3 id, int sectorX, int sectorY, int sectorZ);

bool isExistVoxel(int VoxID, uint3 id);
bool isExistVoxFace(int voxID, uint3 id);
bool isExistVoxLeft(int voxID, uint3 id);
bool isExistVoxDown(int voxID, uint3 id);

void calcVertex(int vertStart, uint3 id);
void testFace(int voxID, int vert, int triangleStart, uint3 id);
void testLeft(int VoxID, int vert, int triangleStart, uint3 id);
void testDown(int VoxID, int vert, int triangleStart, uint3 id);

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{    
    calcSector(id, 0,0,0);
    calcSector(id, 1,0,0);

    calcSector(id, 0,1,0);
    calcSector(id, 1,1,0);

    calcSector(id, 0,0,1);
    calcSector(id, 1,0,1);

    calcSector(id, 0,1,1);
    calcSector(id, 1,1,1);
}

void calcSector(uint3 id, int sectorX, int sectorY, int sectorZ){

    uint3 idGlobal = uint3(id.x + sectorX * 8, id.y + sectorY * 8, id.z + sectorZ * 8); //15, 15, 15
    int voxIDGlobal = (idGlobal.x) + (idGlobal.y * 16) + (idGlobal.z * 16 * 16); //4095

    //3 = side
    //2 = triangles
    //3 = points
    int vertCount = 4 * 6; //24
    int trianCount = 3 * 2 * 3; //3 point on triangle, 2 triangles on side, 3 side //18

    int vertStart = vertCount * voxIDGlobal; //98280
    int trianStart = trianCount * voxIDGlobal; //73710

    calcVertex(vertStart, idGlobal);

    testLeft(voxIDGlobal, vertStart, trianStart, idGlobal);
    //testDown(voxIDGlobal, vertStart, trianStart, idGlobal);
    //testFace(voxIDGlobal, vertStart, trianStart, idGlobal);
}

bool isExistVoxel(int voxID){
    int voxIDMax = 16*16*16;

    if(voxID >= 0 && voxID < voxIDMax && _exist[voxID].num == 1){
        return true;
    }

    return false;
}

bool isExistVoxFace(int voxID, uint3 id){
    if(id.z == 0){
        return false;    
    }

    int voxIDf = voxID - 256;

    return isExistVoxel(voxIDf);
}
bool isExistVoxLeft(int voxID, uint3 id){
    if(id.x == 0){
        return false;    
    }

    int voxIDl = voxID - 1;

    return isExistVoxel(voxIDl);
}
bool isExistVoxDown(int voxID, uint3 id){
    if(id.y == 0){
        return false;    
    }

    int voxIDd = voxID - 16;

    return isExistVoxel(voxIDd);
}

void calcVertex(int vert, uint3 id){
    float sizeVoxel = 1/16.0f;

    float sizeTexelU = 1/(16.0f*16.0f);
    float sizeTexelV = 1/16.0f;

    float posX = id.x * sizeVoxel;
    float posY = id.y * sizeVoxel;
    float posZ = id.z * sizeVoxel;

    //Face
    _vertices[vert + 0].x = posX;
    _vertices[vert + 0].y = posY;
    _vertices[vert + 0].z = posZ;

    _vertices[vert + 1].x = posX;
    _vertices[vert + 1].y = posY + sizeVoxel;
    _vertices[vert + 1].z = posZ;

    _vertices[vert + 2].x = posX + sizeVoxel;
    _vertices[vert + 2].y = posY + sizeVoxel;
    _vertices[vert + 2].z = posZ;

    _vertices[vert + 3].x = posX + sizeVoxel;
    _vertices[vert + 3].y = posY;
    _vertices[vert + 3].z = posZ;

    int numPlus = 0;
    for(numPlus = 0; numPlus < 4; numPlus++){
        _normals[vert + numPlus].x = 0.0f;
        _normals[vert + numPlus].y = 0.0f;
        _normals[vert + numPlus].z = -1.0f;
    }

    //Back
    _vertices[vert + 4 * 1 + 0].x = posX + sizeVoxel;
    _vertices[vert + 4 * 1 + 0].y = posY;
    _vertices[vert + 4 * 1 + 0].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 1 + 1].x = posX + sizeVoxel;
    _vertices[vert + 4 * 1 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 1 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 1 + 2].x = posX;
    _vertices[vert + 4 * 1 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 1 + 2].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 1 + 3].x = posX;
    _vertices[vert + 4 * 1 + 3].y = posY;
    _vertices[vert + 4 * 1 + 3].z = posZ + sizeVoxel;

    for(numPlus = 0; numPlus < 4; numPlus++){
        _normals[vert + 4 * 1 + numPlus].x = 0.0f;
        _normals[vert + 4 * 1 + numPlus].y = 0.0f;
        _normals[vert + 4 * 1 + numPlus].z = 1.0f;
    }

    //Left
    _vertices[vert + 4 * 2 + 0].x = posX;
    _vertices[vert + 4 * 2 + 0].y = posY;
    _vertices[vert + 4 * 2 + 0].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 2 + 1].x = posX;
    _vertices[vert + 4 * 2 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 2 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 2 + 2].x = posX;
    _vertices[vert + 4 * 2 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 2 + 2].z = posZ;

    _vertices[vert + 4 * 2 + 3].x = posX;
    _vertices[vert + 4 * 2 + 3].y = posY;
    _vertices[vert + 4 * 2 + 3].z = posZ;

    for(numPlus = 0; numPlus < 4; numPlus++){
        _normals[vert + 4 * 2 + numPlus].x = -1.0f;
        _normals[vert + 4 * 2 + numPlus].y = 0.0f;
        _normals[vert + 4 * 2 + numPlus].z = 0.0f;
    }

    //Right
    _vertices[vert + 4 * 3 + 0].x = posX + sizeVoxel;
    _vertices[vert + 4 * 3 + 0].y = posY;
    _vertices[vert + 4 * 3 + 0].z = posZ;

    _vertices[vert + 4 * 3 + 1].x = posX + sizeVoxel;
    _vertices[vert + 4 * 3 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 3 + 1].z = posZ;

    _vertices[vert + 4 * 3 + 2].x = posX + sizeVoxel;
    _vertices[vert + 4 * 3 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 3 + 2].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 3 + 3].x = posX + sizeVoxel;
    _vertices[vert + 4 * 3 + 3].y = posY;
    _vertices[vert + 4 * 3 + 3].z = posZ + sizeVoxel;

    for(numPlus = 0; numPlus < 4; numPlus++){
        _normals[vert + 4 * 3 + numPlus].x = 1.0f;
        _normals[vert + 4 * 3 + numPlus].y = 0.0f;
        _normals[vert + 4 * 3 + numPlus].z = 0.0f;
    }

    //Down
    _vertices[vert + 4 * 4 + 0].x = posX + sizeVoxel;
    _vertices[vert + 4 * 4 + 0].y = posY;
    _vertices[vert + 4 * 4 + 0].z = posZ;

    _vertices[vert + 4 * 4 + 1].x = posX + sizeVoxel;
    _vertices[vert + 4 * 4 + 1].y = posY;
    _vertices[vert + 4 * 4 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 4 + 2].x = posX;
    _vertices[vert + 4 * 4 + 2].y = posY;
    _vertices[vert + 4 * 4 + 2].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 4 + 3].x = posX;
    _vertices[vert + 4 * 4 + 3].y = posY;
    _vertices[vert + 4 * 4 + 3].z = posZ;

    for(numPlus = 0; numPlus < 4; numPlus++){
        _normals[vert + 4 * 4 + numPlus].x = 0.0f;
        _normals[vert + 4 * 4 + numPlus].y = -1.0f;
        _normals[vert + 4 * 4 + numPlus].z = 0.0f;
    }

    //UP
    _vertices[vert + 4 * 5 + 0].x = posX;
    _vertices[vert + 4 * 5 + 0].y = posY + sizeVoxel;
    _vertices[vert + 4 * 5 + 0].z = posZ;

    _vertices[vert + 4 * 5 + 1].x = posX;
    _vertices[vert + 4 * 5 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 5 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 5 + 2].x = posX + sizeVoxel;
    _vertices[vert + 4 * 5 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 5 + 2].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 5 + 3].x = posX + sizeVoxel;
    _vertices[vert + 4 * 5 + 3].y = posY + sizeVoxel;
    _vertices[vert + 4 * 5 + 3].z = posZ;

    for(numPlus = 0; numPlus < 4; numPlus++){
        _normals[vert + 4 * 5 + numPlus].x = 0.0f;
        _normals[vert + 4 * 5 + numPlus].y = 1.0f;
        _normals[vert + 4 * 5 + numPlus].z = 0.0f;
    }

    for(int num = 0; num < 4 * 6; num++){
        _uv[vert + num].u = id.x * sizeTexelU + sizeTexelU/2 + id.z * 16 * sizeTexelU;
        _uv[vert + num].v = id.y * sizeTexelV + sizeTexelV/2;
    }
}

void testFace(int voxID, int vert, int triangleStart, uint3 id){

    if(isExistVoxel(voxID) && !isExistVoxFace(voxID, id)){
        //face
        _triangles[triangleStart + 0].num = vert + 4 * 0 + 0;
        _triangles[triangleStart + 1].num = vert + 4 * 0 + 1;
        _triangles[triangleStart + 2].num = vert + 4 * 0 + 2;

        _triangles[triangleStart + 3].num = vert + 4 * 0 + 2;
        _triangles[triangleStart + 4].num = vert + 4 * 0 + 3;
        _triangles[triangleStart + 5].num = vert + 4 * 0 + 0;
    }
    else if(!isExistVoxel(voxID) && isExistVoxFace(voxID, id) && id.z != 0){
        int vertFace = vert - 16*16*4*6;

        //back
        _triangles[triangleStart + 0].num = vertFace + 4 * 1 + 0;
        _triangles[triangleStart + 1].num = vertFace + 4 * 1 + 1;
        _triangles[triangleStart + 2].num = vertFace + 4 * 1 + 2;

        _triangles[triangleStart + 3].num = vertFace + 4 * 1 + 2;
        _triangles[triangleStart + 4].num = vertFace + 4 * 1 + 3;
        _triangles[triangleStart + 5].num = vertFace + 4 * 1 + 0;
    }
    else{
        for(int num = 0; num < 6; num++){
            _triangles[triangleStart + num].num = 0;
        }
    }

    //Last back side
    int triangleLast = (16*16*16*3 + 16*16*0 + id.x + id.y*16)*2*3;
    if(id.z != 15 || !isExistVoxel(voxID)){
        return;
    }
    else{
        _triangles[triangleLast + 0].num = vert + 4 * 1 + 0;
        _triangles[triangleLast + 1].num = vert + 4 * 1 + 1;
        _triangles[triangleLast + 2].num = vert + 4 * 1 + 2;

        _triangles[triangleLast + 3].num = vert + 4 * 1 + 2;
        _triangles[triangleLast + 4].num = vert + 4 * 1 + 3;
        _triangles[triangleLast + 5].num = vert + 4 * 1 + 0;
    }
}

void testLeft(int voxID, int vert, int triangleStart, uint3 id){
    
    if(isExistVoxel(voxID) && !isExistVoxLeft(voxID, id)){

        _triangles[triangleStart + 0 + 6*1].num = vert + 4 * 2 + 0;
        _triangles[triangleStart + 1 + 6*1].num = vert + 4 * 2 + 1;
        _triangles[triangleStart + 2 + 6*1].num = vert + 4 * 2 + 2;

        _triangles[triangleStart + 3 + 6*1].num = vert + 4 * 2 + 2;
        _triangles[triangleStart + 4 + 6*1].num = vert + 4 * 2 + 3;
        _triangles[triangleStart + 5 + 6*1].num = vert + 4 * 2 + 0;
    }
    else if(!isExistVoxel(voxID) && isExistVoxLeft(voxID, id) && id.x != 0){
        int vertLeft = vert - 4*6;

        _triangles[triangleStart + 0 + 6*1].num = vertLeft + 4 * 3 + 0;
        _triangles[triangleStart + 1 + 6*1].num = vertLeft + 4 * 3 + 1;
        _triangles[triangleStart + 2 + 6*1].num = vertLeft + 4 * 3 + 2;

        _triangles[triangleStart + 3 + 6*1].num = vertLeft + 4 * 3 + 2;
        _triangles[triangleStart + 4 + 6*1].num = vertLeft + 4 * 3 + 3;
        _triangles[triangleStart + 5 + 6*1].num = vertLeft + 4 * 3 + 0;
    }
    else{
        for(int num = 0; num < 6; num++){
            _triangles[triangleStart + num + 6*1].num = 0;
        }
    }

    //Last right side
    int triangleLast = (16*16*16*3 + 16*16*1 + id.z + id.y*16)*2*3;
    if(id.x != 15 || !isExistVoxel(voxID)){
        return;
    }
    else{
        _triangles[triangleLast + 0 + 6*1].num = vert + 4 * 3 + 0;
        _triangles[triangleLast + 1 + 6*1].num = vert + 4 * 3 + 1;
        _triangles[triangleLast + 2 + 6*1].num = vert + 4 * 3 + 2;

        _triangles[triangleLast + 3 + 6*1].num = vert + 4 * 3 + 2;
        _triangles[triangleLast + 4 + 6*1].num = vert + 4 * 3 + 3;
        _triangles[triangleLast + 5 + 6*1].num = vert + 4 * 3 + 0;
    }
}

void testDown(int voxID, int vert, int triangleStart, uint3 id){

    if(isExistVoxel(voxID) && !isExistVoxDown(voxID, id)){
        //Down
        _triangles[triangleStart + 0 + 6*2].num = vert + 4 * 4 + 0;
        _triangles[triangleStart + 1 + 6*2].num = vert + 4 * 4 + 1;
        _triangles[triangleStart + 2 + 6*2].num = vert + 4 * 4 + 2;

        _triangles[triangleStart + 3 + 6*2].num = vert + 4 * 4 + 2;
        _triangles[triangleStart + 4 + 6*2].num = vert + 4 * 4 + 3;
        _triangles[triangleStart + 5 + 6*2].num = vert + 4 * 4 + 0;
    }
    else if(!isExistVoxel(voxID) && isExistVoxDown(voxID, id) && id.y != 0){
        int vertDown = vert - 16*4*6;

        //up
        _triangles[triangleStart + 0 + 6*2].num = vertDown + 4 * 5 + 0;
        _triangles[triangleStart + 1 + 6*2].num = vertDown + 4 * 5 + 1;
        _triangles[triangleStart + 2 + 6*2].num = vertDown + 4 * 5 + 2;

        _triangles[triangleStart + 3 + 6*2].num = vertDown + 4 * 5 + 2;
        _triangles[triangleStart + 4 + 6*2].num = vertDown + 4 * 5 + 3;
        _triangles[triangleStart + 5 + 6*2].num = vertDown + 4 * 5 + 0;
    }
    else{
        for(int num = 0; num < 6; num++){
            _triangles[triangleStart + num + 6*2].num = 0;
        }
    }

    //Last up side
    int triangleLast = (16*16*16*3 + 16*16*2 + id.x + id.z*16)*2*3;
    if(id.y != 15 || !isExistVoxel(voxID)){
        return;
    }
    else{
        _triangles[triangleLast + 0 + 6*2].num = vert + 4 * 5 + 0;
        _triangles[triangleLast + 1 + 6*2].num = vert + 4 * 5 + 1;
        _triangles[triangleLast + 2 + 6*2].num = vert + 4 * 5 + 2;

        _triangles[triangleLast + 3 + 6*2].num = vert + 4 * 5 + 2;
        _triangles[triangleLast + 4 + 6*2].num = vert + 4 * 5 + 3;
        _triangles[triangleLast + 5 + 6*2].num = vert + 4 * 5 + 0;
    }
}