// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct Voxel{
    float height;
};
struct Vec3{
    float x;
    float y;
    float z;
};

struct Integer{
    int num;
};

struct TexUV{
    float u;
    float v;
};



RWStructuredBuffer<Vec3> _vertices;
RWStructuredBuffer<Integer> _triangles;
RWStructuredBuffer<TexUV> _uv;
RWStructuredBuffer<Vec3> _normals;

RWStructuredBuffer<Integer> _exist;

//Functions
void calcVoxel(uint3 id);

bool isExistVoxel(int VoxID);
bool isExistVoxFace(int voxID, uint3 id);
bool isExistVoxLeft(int voxID, uint3 id);
bool isExistVoxDown(int voxID, uint3 id);

void calcVertex(uint vertStart, int idx, int idy, int idz);

void testLeft(int VoxID, uint vert, uint triangleStart, uint3 id);
void testDown(int VoxID, uint vert, uint triangleStart, uint3 id);
void testFace(int voxID, uint vert, uint triangleStart, uint3 id);

void testLeftOld(int VoxID, int vert, int triangleStart, uint3 id);
void testDownOld(int VoxID, int vert, int triangleStart, uint3 id);
void testFaceOld(int voxID, int vert, int triangleStart, uint3 id);

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{   
    id = id * 2;
    
    uint3 idLDF = uint3(id.x, id.y, id.z);
    uint3 idRDF = uint3(id.x + 1, id.y, id.z);
    uint3 idLUF = uint3(id.x, id.y + 1, id.z);
    uint3 idRUF = uint3(id.x + 1, id.y + 1, id.z);
    uint3 idLDB = uint3(id.x, id.y, id.z + 1);
    uint3 idRDB = uint3(id.x + 1, id.y, id.z + 1);
    uint3 idLUB = uint3(id.x, id.y + 1, id.z + 1);
    uint3 idRUB = uint3(id.x + 1, id.y + 1, id.z + 1);

    calcVoxel(idLDF);
    calcVoxel(idRDF);

    calcVoxel(idLUF);
    calcVoxel(idRUF);

    calcVoxel(idLDB);
    calcVoxel(idRDB);

    calcVoxel(idLUB);
    calcVoxel(idRUB);
}

void calcVoxel(uint3 idLoc){

    int voxID = (idLoc.x) + (idLoc.y * 16) + (idLoc.z * 16 * 16); //4095

    //3 = side
    //2 = triangles
    //3 = points
    uint vertCount = 4 * 6; //24
    uint trianCount = 3 * 2 * 3; //3 point on triangle, 2 triangles on side, 3 side //18

    uint vertStart = vertCount * voxID; //98280
    uint trianStart = trianCount * voxID; //73710

    calcVertex(vertStart, idLoc.x, idLoc.y, idLoc.z);

    testLeft(voxID, vertStart, trianStart, idLoc);
    //testDown(voxID, vertStart, trianStart, id);
    //testFace(voxID, vertStart, trianStart, id);
}

bool isExistVoxel(int voxID){
    int voxIDMax = 16*16*16;

    if(voxID >= 0 && voxID < voxIDMax && _exist[voxID].num == 1){
        return true;
    }

    return false;
}

bool isExistVoxFace(int voxID, uint3 id){
    if(id.z == 0){
        return false;    
    }

    int voxIDf = voxID - 256;

    return isExistVoxel(voxIDf);
}
bool isExistVoxLeft(int voxID, uint3 id){
    if(id.x == 0){
        return false;    
    }

    int voxIDl = voxID - 1;

    return isExistVoxel(voxIDl);
}
bool isExistVoxDown(int voxID, uint3 id){
    if(id.y == 0){
        return false;    
    }

    int voxIDd = voxID - 16;

    return isExistVoxel(voxIDd);
}

void calcVertex(uint vert, int idx, int idy, int idz){
    float sizeVoxel = 1/16.0f;

    float sizeTexelU = 1/(16.0f*16.0f);
    float sizeTexelV = 1/16.0f;

    float posX = idx * sizeVoxel;
    float posY = idy * sizeVoxel;
    float posZ = idz * sizeVoxel;

    //Left
    _vertices[vert + 4 * 0 + 0].x = posX;
    _vertices[vert + 4 * 0 + 0].y = posY;
    _vertices[vert + 4 * 0 + 0].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 0 + 1].x = posX;
    _vertices[vert + 4 * 0 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 0 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 0 + 2].x = posX;
    _vertices[vert + 4 * 0 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 0 + 2].z = posZ;

    _vertices[vert + 4 * 0 + 3].x = posX;
    _vertices[vert + 4 * 0 + 3].y = posY;
    _vertices[vert + 4 * 0 + 3].z = posZ;

    //Right
    _vertices[vert + 4 * 1 + 0].x = posX + sizeVoxel;
    _vertices[vert + 4 * 1 + 0].y = posY;
    _vertices[vert + 4 * 1 + 0].z = posZ;

    _vertices[vert + 4 * 1 + 1].x = posX + sizeVoxel;
    _vertices[vert + 4 * 1 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 1 + 1].z = posZ;

    _vertices[vert + 4 * 1 + 2].x = posX + sizeVoxel;
    _vertices[vert + 4 * 1 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 1 + 2].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 1 + 3].x = posX + sizeVoxel;
    _vertices[vert + 4 * 1 + 3].y = posY;
    _vertices[vert + 4 * 1 + 3].z = posZ + sizeVoxel;

    //Down
    _vertices[vert + 4 * 2 + 0].x = posX + sizeVoxel;
    _vertices[vert + 4 * 2 + 0].y = posY;
    _vertices[vert + 4 * 2 + 0].z = posZ;

    _vertices[vert + 4 * 2 + 1].x = posX + sizeVoxel;
    _vertices[vert + 4 * 2 + 1].y = posY;
    _vertices[vert + 4 * 2 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 2 + 2].x = posX;
    _vertices[vert + 4 * 2 + 2].y = posY;
    _vertices[vert + 4 * 2 + 2].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 2 + 3].x = posX;
    _vertices[vert + 4 * 2 + 3].y = posY;
    _vertices[vert + 4 * 2 + 3].z = posZ;

    //UP
    _vertices[vert + 4 * 3 + 0].x = posX;
    _vertices[vert + 4 * 3 + 0].y = posY + sizeVoxel;
    _vertices[vert + 4 * 3 + 0].z = posZ;

    _vertices[vert + 4 * 3 + 1].x = posX;
    _vertices[vert + 4 * 3 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 3 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 3 + 2].x = posX + sizeVoxel;
    _vertices[vert + 4 * 3 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 3 + 2].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 3 + 3].x = posX + sizeVoxel;
    _vertices[vert + 4 * 3 + 3].y = posY + sizeVoxel;
    _vertices[vert + 4 * 3 + 3].z = posZ;

    //Face
    _vertices[vert + 4 * 4 + 0].x = posX;
    _vertices[vert + 4 * 4 + 0].y = posY;
    _vertices[vert + 4 * 4 + 0].z = posZ;

    _vertices[vert + 4 * 4 + 1].x = posX;
    _vertices[vert + 4 * 4 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 4 + 1].z = posZ;

    _vertices[vert + 4 * 4 + 2].x = posX + sizeVoxel;
    _vertices[vert + 4 * 4 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 4 + 2].z = posZ;

    _vertices[vert + 4 * 4 + 3].x = posX + sizeVoxel;
    _vertices[vert + 4 * 4 + 3].y = posY;
    _vertices[vert + 4 * 4 + 3].z = posZ;

    //Back
    _vertices[vert + 4 * 5 + 0].x = posX + sizeVoxel;
    _vertices[vert + 4 * 5 + 0].y = posY;
    _vertices[vert + 4 * 5 + 0].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 5 + 1].x = posX + sizeVoxel;
    _vertices[vert + 4 * 5 + 1].y = posY + sizeVoxel;
    _vertices[vert + 4 * 5 + 1].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 5 + 2].x = posX;
    _vertices[vert + 4 * 5 + 2].y = posY + sizeVoxel;
    _vertices[vert + 4 * 5 + 2].z = posZ + sizeVoxel;

    _vertices[vert + 4 * 5 + 3].x = posX;
    _vertices[vert + 4 * 5 + 3].y = posY;
    _vertices[vert + 4 * 5 + 3].z = posZ + sizeVoxel;

    //normals
    for(int num = 0; num < 4; num++){
        _normals[vert + 4 * 0 + num].x = -1.0f;
        _normals[vert + 4 * 0 + num].y = 0.0f;
        _normals[vert + 4 * 0 + num].z = 0.0f;

        _normals[vert + 4 * 1 + num].x = 1.0f;
        _normals[vert + 4 * 1 + num].y = 0.0f;
        _normals[vert + 4 * 1 + num].z = 0.0f;

        _normals[vert + 4 * 2 + num].x = 0.0f;
        _normals[vert + 4 * 2 + num].y = -1.0f;
        _normals[vert + 4 * 2 + num].z = 0.0f;

        _normals[vert + 4 * 3 + num].x = 0.0f;
        _normals[vert + 4 * 3 + num].y = 1.0f;
        _normals[vert + 4 * 3 + num].z = 0.0f;

        _normals[vert + 4 * 4 + num].x = 0.0f;
        _normals[vert + 4 * 4 + num].y = 0.0f;
        _normals[vert + 4 * 4 + num].z = -1.0f;

        _normals[vert + 4 * 5 + num].x = 0.0f;
        _normals[vert + 4 * 5 + num].y = 0.0f;
        _normals[vert + 4 * 5 + num].z = 1.0f;
    }

    for(int num = 0; num < 4 * 6; num++){
        _uv[vert + num].u = idx * sizeTexelU + sizeTexelU/2 + idz * 16 * sizeTexelU;
        _uv[vert + num].v = idy * sizeTexelV + sizeTexelV/2;
    }
}

void testLeft(int voxID, uint vert, uint triangleStart, uint3 id){
    if(isExistVoxel(voxID) && true){
        //left
        _triangles[triangleStart + 0].num = vert + 4 * 0 + 0;
        _triangles[triangleStart + 1].num = vert + 4 * 0 + 1;
        _triangles[triangleStart + 2].num = vert + 4 * 0 + 2;

        _triangles[triangleStart + 3].num = vert + 4 * 0 + 2;
        _triangles[triangleStart + 4].num = vert + 4 * 0 + 3;
        _triangles[triangleStart + 5].num = vert + 4 * 0 + 0;
    }
}
void testDown(int voxID, uint vert, uint triangleStart, uint3 id){
    
}
void testFace(int voxID, uint vert, uint triangleStart, uint3 id){
    
}

void testFaceOld(int voxID, int vert, int triangleStart, uint3 id){

    if(isExistVoxel(voxID) && !isExistVoxFace(voxID, id)){
        //face
        _triangles[triangleStart + 0].num = vert + 4 * 0 + 0;
        _triangles[triangleStart + 1].num = vert + 4 * 0 + 1;
        _triangles[triangleStart + 2].num = vert + 4 * 0 + 2;

        _triangles[triangleStart + 3].num = vert + 4 * 0 + 2;
        _triangles[triangleStart + 4].num = vert + 4 * 0 + 3;
        _triangles[triangleStart + 5].num = vert + 4 * 0 + 0;
    }
    else if(!isExistVoxel(voxID) && isExistVoxFace(voxID, id) && id.z != 0){
        int vertFace = vert - 16*16*4*6;

        //back
        _triangles[triangleStart + 0].num = vertFace + 4 * 1 + 0;
        _triangles[triangleStart + 1].num = vertFace + 4 * 1 + 1;
        _triangles[triangleStart + 2].num = vertFace + 4 * 1 + 2;

        _triangles[triangleStart + 3].num = vertFace + 4 * 1 + 2;
        _triangles[triangleStart + 4].num = vertFace + 4 * 1 + 3;
        _triangles[triangleStart + 5].num = vertFace + 4 * 1 + 0;
    }
    else{
        for(int num = 0; num < 6; num++){
            _triangles[triangleStart + num].num = 0;
        }
    }

    //Last back side
    int triangleLast = (16*16*16*3 + 16*16*0 + id.x + id.y*16)*2*3;
    if(id.z != 15 || !isExistVoxel(voxID)){
        return;
    }
    else{
        _triangles[triangleLast + 0].num = vert + 4 * 1 + 0;
        _triangles[triangleLast + 1].num = vert + 4 * 1 + 1;
        _triangles[triangleLast + 2].num = vert + 4 * 1 + 2;

        _triangles[triangleLast + 3].num = vert + 4 * 1 + 2;
        _triangles[triangleLast + 4].num = vert + 4 * 1 + 3;
        _triangles[triangleLast + 5].num = vert + 4 * 1 + 0;
    }
}

void testLeftOld(int voxID, int vert, int triangleStart, uint3 id){
    
    if(isExistVoxel(voxID) && !isExistVoxLeft(voxID, id)){

        _triangles[triangleStart + 0 + 6*1].num = vert + 4 * 2 + 0;
        _triangles[triangleStart + 1 + 6*1].num = vert + 4 * 2 + 1;
        _triangles[triangleStart + 2 + 6*1].num = vert + 4 * 2 + 2;

        _triangles[triangleStart + 3 + 6*1].num = vert + 4 * 2 + 2;
        _triangles[triangleStart + 4 + 6*1].num = vert + 4 * 2 + 3;
        _triangles[triangleStart + 5 + 6*1].num = vert + 4 * 2 + 0;
    }
    else if(!isExistVoxel(voxID) && isExistVoxLeft(voxID, id) && id.x != 0){
        int vertLeft = vert - 4*6;

        _triangles[triangleStart + 0 + 6*1].num = vertLeft + 4 * 3 + 0;
        _triangles[triangleStart + 1 + 6*1].num = vertLeft + 4 * 3 + 1;
        _triangles[triangleStart + 2 + 6*1].num = vertLeft + 4 * 3 + 2;

        _triangles[triangleStart + 3 + 6*1].num = vertLeft + 4 * 3 + 2;
        _triangles[triangleStart + 4 + 6*1].num = vertLeft + 4 * 3 + 3;
        _triangles[triangleStart + 5 + 6*1].num = vertLeft + 4 * 3 + 0;
    }
    else{
        for(int num = 0; num < 6; num++){
            _triangles[triangleStart + num + 6*1].num = 0;
        }
    }

    //Last right side
    int triangleLast = (16*16*16*3 + 16*16*1 + id.z + id.y*16)*2*3;
    if(id.x != 15 || !isExistVoxel(voxID)){
        return;
    }
    else{
        _triangles[triangleLast + 0 + 6*1].num = vert + 4 * 3 + 0;
        _triangles[triangleLast + 1 + 6*1].num = vert + 4 * 3 + 1;
        _triangles[triangleLast + 2 + 6*1].num = vert + 4 * 3 + 2;

        _triangles[triangleLast + 3 + 6*1].num = vert + 4 * 3 + 2;
        _triangles[triangleLast + 4 + 6*1].num = vert + 4 * 3 + 3;
        _triangles[triangleLast + 5 + 6*1].num = vert + 4 * 3 + 0;
    }
}

void testDownOld(int voxID, int vert, int triangleStart, uint3 id){

    if(isExistVoxel(voxID) && !isExistVoxDown(voxID, id)){
        //Down
        _triangles[triangleStart + 0 + 6*2].num = vert + 4 * 4 + 0;
        _triangles[triangleStart + 1 + 6*2].num = vert + 4 * 4 + 1;
        _triangles[triangleStart + 2 + 6*2].num = vert + 4 * 4 + 2;

        _triangles[triangleStart + 3 + 6*2].num = vert + 4 * 4 + 2;
        _triangles[triangleStart + 4 + 6*2].num = vert + 4 * 4 + 3;
        _triangles[triangleStart + 5 + 6*2].num = vert + 4 * 4 + 0;
    }
    else if(!isExistVoxel(voxID) && isExistVoxDown(voxID, id) && id.y != 0){
        int vertDown = vert - 16*4*6;

        //up
        _triangles[triangleStart + 0 + 6*2].num = vertDown + 4 * 5 + 0;
        _triangles[triangleStart + 1 + 6*2].num = vertDown + 4 * 5 + 1;
        _triangles[triangleStart + 2 + 6*2].num = vertDown + 4 * 5 + 2;

        _triangles[triangleStart + 3 + 6*2].num = vertDown + 4 * 5 + 2;
        _triangles[triangleStart + 4 + 6*2].num = vertDown + 4 * 5 + 3;
        _triangles[triangleStart + 5 + 6*2].num = vertDown + 4 * 5 + 0;
    }
    else{
        for(int num = 0; num < 6; num++){
            _triangles[triangleStart + num + 6*2].num = 0;
        }
    }

    //Last up side
    int triangleLast = (16*16*16*3 + 16*16*2 + id.x + id.z*16)*2*3;
    if(id.y != 15 || !isExistVoxel(voxID)){
        return;
    }
    else{
        _triangles[triangleLast + 0 + 6*2].num = vert + 4 * 5 + 0;
        _triangles[triangleLast + 1 + 6*2].num = vert + 4 * 5 + 1;
        _triangles[triangleLast + 2 + 6*2].num = vert + 4 * 5 + 2;

        _triangles[triangleLast + 3 + 6*2].num = vert + 4 * 5 + 2;
        _triangles[triangleLast + 4 + 6*2].num = vert + 4 * 5 + 3;
        _triangles[triangleLast + 5 + 6*2].num = vert + 4 * 5 + 0;
    }
}